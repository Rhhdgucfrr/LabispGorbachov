

#include <iostream>


struct Tree {
	int   val;
	Tree* left;
	Tree* right;
};

Tree* InsertNode(Tree* node, int val);
void Search(Tree* x, int value);
void  PrintNode(std::ostream& _out, const Tree* node);
void  ClearNode(Tree* node);
void print_menu();

Tree* DeleteNode(Tree* node, int val) {
	if (node == NULL)
		return node;
	if (val == node->val) {

		Tree* tmp;
		if (node->right == NULL)
			tmp = node->left;
		else {

			Tree* ptr = node->right;
			if (ptr->left == NULL) {
				ptr->left = node->left;
				tmp = ptr;
			}
			else {

				Tree* pmin = ptr->left;
				while (pmin->left != NULL) {
					ptr = pmin;
					pmin = ptr->left;
				}
				ptr->left = pmin->right;
				pmin->left = node->left;
				pmin->right = node->right;
				tmp = pmin;
			}
		}

		delete node;
		return tmp;
	}
	else if (val < node->val)
		node->left = DeleteNode(node->left, val);
	else
		node->right = DeleteNode(node->right, val);
	return node;
}



int main(void) {
	setlocale(LC_ALL, "Russian");
	Tree* tree = NULL;
	int n = 0;
	int value = 0;
	bool tt = false;
	
	int chousen = 0;
	while (tt==false) {
		print_menu();
		std::cout << ("Выберите действие") << std::endl;		
			std::cin >> chousen;
	
		switch (chousen) 
		{
		case 1: {
			bool insert = true;
			while (insert != false)
			{
				try {
					std::string g = "";
					std::cout << ("Введите элемент") << std::endl;
					std::cin >> value;
					tree = InsertNode(tree, value);
					std::cout << ("Продолжить? Y/N") << std::endl;
					std::cin >> g;
					if (g == "Y")
					{
					}
					else { insert = false; }
					std::cin.clear();
				}
				catch (std::exception a) { std::cout<<(""); }
			}

			break;
		}		
		case 2:		
			try {
				std::cout << ("Введите элемент который следует удалить") << std::endl;
				std::cin >> value;
				tree = DeleteNode(tree, value);
				std::cin.clear();
				break;
			}
			catch (int value) { " exeption of type  "; return 0; }
		case 3: 
		{
			try
			{		
		        std::cout << ("Введите элемент который следует найти в памяти") << std::endl;
				int value = 0;
				std::cin >> value;
				Search(tree, value);
				std::cin.clear();
				break;				
			}
			catch (std::exception a) { std::cout << ("Ошибка ввода данных"); break; }
		}
		case 4: 
		{

		}
		case 5: 
		{
			std::cout << ("Дерево имеет вид") << std::endl;
			PrintNode(std::cout, tree);
			std::cout << std::endl;
			break;
		}
		
		case 6:
		{
			tt = true;
			break;
		}		
		std::cin.clear();
		break;
		}
	}
	ClearNode(tree);
	return 0;
}
void print_menu() 
{	
	std::cout << ("1 Добавить") << std::endl;
	std::cout << ("2 Удалить") << std::endl;
	std::cout << ("3 Поиск") << std::endl;
	std::cout << ("4 Сортировка") << std::endl;
	std::cout << ("5 Просмотр") << std::endl;
	std::cout << ("6 Выход") << std::endl;
}
Tree* InsertNode(Tree* node, int val) {
	try
	{
		if (node == NULL) {
			node = new (std::nothrow) Tree();
			if (node != NULL) {
				node->val = val;
				node->left = node->right = NULL;
			}
			return node;
		}
		if (val < node->val)
			node->left = InsertNode(node->left, val);
		else
			node->right = InsertNode(node->right, val);
		return node;
	}
	catch (std::exception) { std::cout << ("Ошибка добавления элемента дерева");return node;
	}
	
}
 void Search(Tree* x, int value) 
{
	 while(x->val != value) 
	 {
		 if (x != NULL)
		 {
			 try 
			 {
				 if (x->left->val == NULL ||  x->right->val==NULL) {}
				 else {
					 std::cout << x->left->val << std::endl;
			
					
				 }
			 }
			 catch (std::exception) {}
			 

		 }
	 }
}
void PrintNode(std::ostream& _out, const Tree* node) {
	if (node != NULL) {
		if (node->left != NULL)
			PrintNode(_out, node->left);

		_out << node->val << ' ';

		if (node->right != NULL)
			PrintNode(_out, node->right);
	}
}
void ClearNode(Tree* node) {
	if (node != NULL) {
		if (node->left != NULL)
			ClearNode(node->left);
		if (node->right != NULL)
			ClearNode(node->right);
		delete node;
	}
}